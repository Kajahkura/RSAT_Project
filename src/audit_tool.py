import sys
import os
import platform
import subprocess
import socket
import ctypes
import concurrent.futures
import plistlib
from datetime import datetime

# Windows Registry imports (only works on Windows)
if platform.system() == 'Windows':
    import winreg

# --- CONFIGURATION ---
TARGET_PORTS = [21, 22, 23, 25, 53, 80, 139, 445, 3389, 5900, 8080]

HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Audit Report</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 20px; color: #333; background-color: #f4f4f9; }}
        .container {{ max-width: 900px; margin: 0 auto; background: white; padding: 40px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }}
        h1 {{ border-bottom: 2px solid #007bff; padding-bottom: 10px; color: #2c3e50; }}
        h2 {{ margin-top: 30px; color: #34495e; font-size: 1.2em; }}
        table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
        th, td {{ padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f8f9fa; font-weight: 600; color: #555; }}
        .status-pass {{ color: #155724; background-color: #d4edda; font-weight: bold; border-radius: 4px; padding: 4px 8px; display: inline-block; }}
        .status-fail {{ color: #721c24; background-color: #f8d7da; font-weight: bold; border-radius: 4px; padding: 4px 8px; display: inline-block; }}
        .status-warn {{ color: #856404; background-color: #fff3cd; font-weight: bold; border-radius: 4px; padding: 4px 8px; display: inline-block; }}
        .footer {{ margin-top: 50px; font-size: 0.8em; color: #777; text-align: center; border-top: 1px solid #eee; padding-top: 20px; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Security Audit Report</h1>
        <p><strong>Hostname:</strong> {hostname}</p>
        <p><strong>OS:</strong> {os_details}</p>
        <p><strong>Scan Date:</strong> {timestamp}</p>
        
        <h2>1. Disk Encryption</h2>
        <table>
            <thead><tr><th>Check</th><th>Status</th><th>Details</th></tr></thead>
            <tbody>{encryption_rows}</tbody>
        </table>

        <h2>2. Network Perimeter</h2>
        <table>
            <thead><tr><th>Check</th><th>Status</th><th>Details</th></tr></thead>
            <tbody>{firewall_rows}</tbody>
        </table>

        <h2>3. System Hygiene (Patching)</h2>
        <table>
            <thead><tr><th>Check</th><th>Status</th><th>Details</th></tr></thead>
            <tbody>{patch_rows}</tbody>
        </table>
        
        <div class="footer">
            <p>This audit represents a point-in-time assessment. Generated by FINFIX Remote Security Audit Tool.</p>
        </div>
    </div>
</body>
</html>
"""

class AdminManager:
    """Handles privilege detection and self-escalation."""
    def __init__(self):
        self.os_type = platform.system()

    def is_admin(self):
        if self.os_type == 'Windows':
            try:
                return ctypes.windll.shell32.IsUserAnAdmin()
            except:
                return False
        elif self.os_type == 'Darwin': # macOS
            return os.getuid() == 0
        return False

    def elevate(self):
        """Relaunches the script with admin privileges."""
        print("[!] Privileges required. Requesting elevation...")
        if self.os_type == 'Windows':
            # Use ShellExecuteW to trigger UAC
            ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
            sys.exit() # Exit the unprivileged instance
        elif self.os_type == 'Darwin':
            # Use sudo with os.execvp to replace the process
            print("[*] You will be prompted for your password by sudo.")
            
            # Determine if running as script or frozen binary
            if getattr(sys, 'frozen', False):
                # If frozen by PyInstaller, sys.executable is the binary itself
                cmd = ["sudo", sys.executable] + sys.argv[1:]
            else:
                # If running raw python script
                cmd = ["sudo", sys.executable] + sys.argv
                
            os.execvp("sudo", cmd)

class AuditEngine:
    """Core logic for gathering system security data."""
    def __init__(self):
        self.os_type = platform.system()
        self.results = {
            'encryption': [],
            'firewall': [],
            'patching': []
        }

    def run_all_checks(self):
        print("[*] Checking Disk Encryption...")
        self.check_disk_encryption()
        print("[*] Checking Firewall & Ports...")
        self.check_network()
        print("[*] Checking Patch Status...")
        self.check_patching()

    # --- ENCRYPTION CHECKS ---
    def check_disk_encryption(self):
        if self.os_type == 'Windows':
            self._windows_bitlocker()
        elif self.os_type == 'Darwin':
            self._mac_filevault()

    def _windows_bitlocker(self):
        # Method 1: PowerShell (Preferred)
        try:
            cmd = ["powershell", "-Command", "Get-BitLockerVolume -MountPoint C: | Select-Object -ExpandProperty ProtectionStatus"]
            output = subprocess.check_output(cmd, creationflags=subprocess.CREATE_NO_WINDOW).decode().strip()
            if "1" in output:
                self.results['encryption'].append({'name': 'BitLocker Status', 'status': 'PASS', 'details': 'Protection On'})
                return
        except:
            pass 

        # Method 2: manage-bde (Fallback)
        try:
            output = subprocess.check_output("manage-bde -status C:", shell=True).decode()
            if "Percentage Encrypted: 100%" in output:
                self.results['encryption'].append({'name': 'BitLocker Status', 'status': 'PASS', 'details': 'Drive Fully Encrypted'})
            else:
                self.results['encryption'].append({'name': 'BitLocker Status', 'status': 'FAIL', 'details': 'Encryption not 100% or Off'})
        except:
            self.results['encryption'].append({'name': 'BitLocker Status', 'status': 'WARN', 'details': 'Could not verify (Admin required?)'})

    def _mac_filevault(self):
        try:
            output = subprocess.check_output(["fdesetup", "status"]).decode()
            if "FileVault is On" in output:
                self.results['encryption'].append({'name': 'FileVault Status', 'status': 'PASS', 'details': 'FileVault Enabled'})
            else:
                self.results['encryption'].append({'name': 'FileVault Status', 'status': 'FAIL', 'details': 'FileVault Disabled'})
        except subprocess.CalledProcessError:
            self.results['encryption'].append({'name': 'FileVault Status', 'status': 'WARN', 'details': 'Permission Denied (Check TCC/Terminal Access)'})

    # --- NETWORK CHECKS ---
    def check_network(self):
        # 1. Firewall Check
        if self.os_type == 'Windows':
            self._windows_firewall()
        elif self.os_type == 'Darwin':
            self._mac_firewall()
        
        # 2. Port Scan
        self._port_scan()

    def _windows_firewall(self):
        try:
            cmd = ["powershell", "-Command", "Get-NetFirewallProfile | Select-Object Name, Enabled"]
            output = subprocess.check_output(cmd, creationflags=subprocess.CREATE_NO_WINDOW).decode()
            if "True" in output:
                self.results['firewall'].append({'name': 'Windows Firewall', 'status': 'PASS', 'details': 'Active Profile Enabled'})
            else:
                self.results['firewall'].append({'name': 'Windows Firewall', 'status': 'FAIL', 'details': 'Firewall Disabled'})
        except:
             self.results['firewall'].append({'name': 'Windows Firewall', 'status': 'WARN', 'details': 'Check Failed'})

    def _mac_firewall(self):
        try:
            # Using socketfilterfw directly
            cmd = ["/usr/libexec/ApplicationFirewall/socketfilterfw", "--getglobalstate"]
            output = subprocess.check_output(cmd).decode()
            if "State = 1" in output or "State = 2" in output:
                self.results['firewall'].append({'name': 'ALF (Application Firewall)', 'status': 'PASS', 'details': 'Firewall Enabled'})
            else:
                self.results['firewall'].append({'name': 'ALF (Application Firewall)', 'status': 'FAIL', 'details': 'Firewall Disabled'})
        except:
            self.results['firewall'].append({'name': 'ALF Check', 'status': 'WARN', 'details': 'Unable to query socketfilterfw'})

    def _port_scan(self):
        open_ports = []
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            future_to_port = {executor.submit(self._check_socket, p): p for p in TARGET_PORTS}
            for future in concurrent.futures.as_completed(future_to_port):
                port = future_to_port[future]
                if future.result():
                    open_ports.append(port)
        
        if open_ports:
            self.results['firewall'].append({'name': 'Open Ports (Localhost)', 'status': 'FAIL', 'details': f"Exposed: {open_ports}"})
        else:
            self.results['firewall'].append({'name': 'Open Ports (Localhost)', 'status': 'PASS', 'details': 'No High-Risk Ports Listening'})

    def _check_socket(self, port):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(0.5)
        try:
            result = s.connect_ex(('127.0.0.1', port))
            s.close()
            return port if result == 0 else None
        except:
            return None

    # --- PATCHING CHECKS ---
    def check_patching(self):
        if self.os_type == 'Windows':
            self._windows_patching()
        elif self.os_type == 'Darwin':
            self._mac_patching()

    def _windows_patching(self):
        reboot_required = False
        paths = [
            r"SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\RebootPending",
            r"SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update\RebootRequired",
        ]
        try:
            for path in paths:
                try:
                    key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, path)
                    reboot_required = True
                    winreg.CloseKey(key)
                except FileNotFoundError:
                    continue
            
            if reboot_required:
                self.results['patching'].append({'name': 'Pending Reboot', 'status': 'FAIL', 'details': 'Reboot Required to Finish Updates'})
            else:
                self.results['patching'].append({'name': 'Pending Reboot', 'status': 'PASS', 'details': 'No Pending Reboots'})
        except:
             self.results['patching'].append({'name': 'Patch Status', 'status': 'WARN', 'details': 'Access Denied to Registry'})

    def _mac_patching(self):
        plist_path = "/Library/Preferences/com.apple.SoftwareUpdate.plist"
        if os.path.exists(plist_path):
            try:
                with open(plist_path, 'rb') as fp:
                    pl = plistlib.load(fp)
                    if 'LastRecommendedUpdatesAvailable' in pl and pl['LastRecommendedUpdatesAvailable'] > 0:
                        self.results['patching'].append({'name': 'macOS Updates', 'status': 'FAIL', 'details': 'Updates Pending Install'})
                    else:
                        self.results['patching'].append({'name': 'macOS Updates', 'status': 'PASS', 'details': 'System appears up to date'})
            except Exception as e:
                self.results['patching'].append({'name': 'macOS Updates', 'status': 'WARN', 'details': 'Could not read Update Plist'})
        else:
             self.results['patching'].append({'name': 'macOS Updates', 'status': 'WARN', 'details': 'Update history not found'})


    # --- REPORT GENERATION ---
    def generate_report(self):
        def make_rows(result_list):
            html = ""
            for item in result_list:
                css = f"status-{item['status'].lower()}"
                html += f"<tr><td>{item['name']}</td><td><span class='{css}'>{item['status']}</span></td><td>{item['details']}</td></tr>"
            return html

        report_html = HTML_TEMPLATE.format(
            hostname=platform.node(),
            os_details=f"{platform.system()} {platform.release()}",
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M"),
            encryption_rows=make_rows(self.results['encryption']),
            firewall_rows=make_rows(self.results['firewall']),
            patch_rows=make_rows(self.results['patching'])
        )

        filename = f"Audit_Report_{platform.node()}.html"
        with open(filename, "w") as f:
            f.write(report_html)
        
        return filename

# --- MAIN EXECUTION ---
if __name__ == "__main__":
    print("--- FINFIX Remote Security Audit Tool (RSAT) ---")
    
    # 1. Check Admin
    admin_mgr = AdminManager()
    if not admin_mgr.is_admin():
        # Will exit this instance and start a new one
        admin_mgr.elevate()
    
    print("[+] Running with Elevated Privileges.")
    
    # 2. Run Audit
    audit = AuditEngine()
    audit.run_all_checks()
    
    # 3. Generate Report
    print("[*] Generating Report...")
    report_file = audit.generate_report()
    
    print(f"\n[SUCCESS] Audit Complete. Report saved to:\n{os.path.abspath(report_file)}")
    
    # 4. Pause for user to see result (Important for console binaries)
    input("\nPress Enter to close this window...")
    